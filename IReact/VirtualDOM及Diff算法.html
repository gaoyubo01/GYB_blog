<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <meta name="theme-color" content="#3367D6"/>
  <link rel="apple-touch-icon" href="/icons-192.png">
  <link rel="manifest" href="/manifest.json">
  


  <meta name="generator" content="Hexo 6.3.0">

  

  

  
    <meta name="author" content="John Doe">
  

  

  

  <title>GYB的博客</title>

  

  
    <link rel="shortcut icon" href="https://img1.baidu.com/it/u=1088540074,3334562162&fm=253&fmt=auto&app=138&f=JPEG?w=237&h=221">
  

  

  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@1.1.3/index.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlightjs@9.16.2/styles/monokai.css">
  

  
<link rel="stylesheet" href="/GYB_blog/css/style.css">

</head>
<body>
  <div class="root-container">
    
<!-- header container -->
<header class="header-container">
  
    <div class="post-image" style="background-image: url(https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fbpic.588ku.com%2Fback_pic%2F03%2F73%2F08%2F3457b9b98014f6e.jpg&amp;refer=http%3A%2F%2Fbpic.588ku.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto?sec=1668428880&amp;t=fa9b9b9da08346caa158bab8e9ab892c)"></div>
  

  <!-- navbar -->
<nav class="navbar">
  <div class="navbar-content">
    <!-- logo -->
    <div class="navbar-logo">
      <a href="/GYB_blog/">
        
          GYB的博客
        
      </a>
    </div>
    <!-- link -->
    <div class="navbar-link">
      <div class="navbar-btn">
        <div></div>
        <div></div>
        <div></div>
      </div>
      <ul class="navbar-list">
        
          <li class="navbar-list-item"><a href="/GYB_blog/">首页</a></li>
        
          <li class="navbar-list-item"><a href="https://gaoyubo01.github.io/docs/">友链</a></li>
        
          <li class="navbar-list-item"><a href="/GYB_blog/about">关于</a></li>
        
      </ul>
    </div>
  </div>
</nav>

  
  

  
  

  
  

  
  

  
  

  
  
    <div class="header-content">
      <div class="post-text layout-block layout-padding">
        <h1 class="title-wrap"></h1>
        
      </div>
    </div>
  
  
</header>

    <!-- 分页(其他自定义页面) -->

<!-- 自定义页面 -->

<div class="body-container">
  <article class="content-container layout-block post-container">
    <div class="article-info">
      
      <section class="article-entry markdown-body layout-margin content-padding--large soft-size--large soft-style--box">
        <h2 id="二-Virtual-DOM-及-Diff-算法"><a href="#二-Virtual-DOM-及-Diff-算法" class="headerlink" title="二.Virtual DOM 及 Diff 算法"></a>二.Virtual DOM 及 Diff 算法</h2><h2 id="1-JSX-到底是什么"><a href="#1-JSX-到底是什么" class="headerlink" title="1.  JSX 到底是什么"></a>1.  JSX 到底是什么</h2><p>使用 React 就一定会写 JSX，JSX 到底是什么呢？它是一种 JavaScript 语法的扩展，React 使用它来描述用户界面长成什么样子。虽然它看起来非常像 HTML，但它确实是 JavaScript 。在 React 代码执行之前，Babel 会对将 JSX 编译为 React API.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div className=&quot;container&quot;&gt;</span><br><span class="line">  &lt;h3&gt;Hello React&lt;/h3&gt;</span><br><span class="line">  &lt;p&gt;React is great &lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">React.createElement(</span><br><span class="line">  &quot;div&quot;,</span><br><span class="line">  &#123;</span><br><span class="line">    className: &quot;container&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  React.createElement(&quot;h3&quot;, null, &quot;Hello React&quot;),</span><br><span class="line">  React.createElement(&quot;p&quot;, null, &quot;React is great&quot;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>从两种语法对比来看，JSX 语法的出现是为了让 React 开发人员编写用户界面代码更加轻松。</p>
<p><a target="_blank" rel="noopener" href="https://babeljs.io/repl">Babel REPL</a></p>
<h2 id="2-DOM-操作问题"><a href="#2-DOM-操作问题" class="headerlink" title="2. DOM 操作问题"></a>2. DOM 操作问题</h2><p>在现代 web 应用程序中使用 JavaScript 操作 DOM 是必不可少的，但遗憾的是它比其他大多数 JavaScript 操作要慢的多。</p>
<p>大多数 JavaScript 框架对于 DOM 的更新远远超过其必须进行的更新，从而使得这种缓慢操作变得更糟。</p>
<p>例如假设你有包含十个项目的列表，你仅仅更改了列表中的第一项，大多数 JavaScript 框架会重建整个列表，这比必要的工作要多十倍。</p>
<p>更新效率低下已经成为严重问题，为了解决这个问题，React 普及了一种叫做 Virtual DOM 的东西，Virtual DOM 出现的目的就是为了提高 JavaScript 操作 DOM 对象的效率。</p>
<h2 id="3-什么是-Virtual-DOM"><a href="#3-什么是-Virtual-DOM" class="headerlink" title="3. 什么是 Virtual DOM"></a>3. 什么是 Virtual DOM</h2><p>在 React 中，每个 DOM 对象都有一个对应的 Virtual DOM 对象，它是 DOM 对象的 JavaScript 对象表现形式，其实就是使用 JavaScript 对象来描述 DOM 对象信息，比如 DOM 对象的类型是什么，它身上有哪些属性，它拥有哪些子元素。</p>
<p>可以把 Virtual DOM 对象理解为 DOM 对象的副本，但是它不能直接显示在屏幕上。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div className=&quot;container&quot;&gt;</span><br><span class="line">  &lt;h3&gt;Hello React&lt;/h3&gt;</span><br><span class="line">  &lt;p&gt;React is great &lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  type: &quot;div&quot;,</span><br><span class="line">  props: &#123; className: &quot;container&quot; &#125;,</span><br><span class="line">  children: [</span><br><span class="line">    &#123;</span><br><span class="line">      type: &quot;h3&quot;,</span><br><span class="line">      props: null,</span><br><span class="line">      children: [</span><br><span class="line">        &#123;</span><br><span class="line">          type: &quot;text&quot;,</span><br><span class="line">          props: &#123;</span><br><span class="line">            textContent: &quot;Hello React&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      type: &quot;p&quot;,</span><br><span class="line">      props: null,</span><br><span class="line">      children: [</span><br><span class="line">        &#123;</span><br><span class="line">          type: &quot;text&quot;,</span><br><span class="line">          props: &#123;</span><br><span class="line">            textContent: &quot;React is great&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-Virtual-DOM-如何提升效率"><a href="#4-Virtual-DOM-如何提升效率" class="headerlink" title="4. Virtual DOM 如何提升效率"></a>4. Virtual DOM 如何提升效率</h2><p>精准找出发生变化的 DOM 对象，只更新发生变化的部分。</p>
<p>在 React 第一次创建 DOM 对象后，会为每个 DOM 对象创建其对应的 Virtual DOM 对象，在 DOM 对象发生更新之前，React 会先更新所有的 Virtual DOM 对象，然后 React 会将更新后的 Virtual DOM 和 更新前的 Virtual DOM 进行比较，从而找出发生变化的部分，React 会将发生变化的部分更新到真实的 DOM 对象中，React 仅更新必要更新的部分。</p>
<p>Virtual DOM 对象的更新和比较仅发生在内存中，不会在视图中渲染任何内容，所以这一部分的性能损耗成本是微不足道的。</p>
<img src="./images2/1.png" style="margin: 20px 0;width: 80%"/>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;container&quot;&gt;</span><br><span class="line">	&lt;p&gt;Hello React&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;container&quot;&gt;</span><br><span class="line">	&lt;p&gt;Hello Angular&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const before = &#123;</span><br><span class="line">  type: &quot;div&quot;,</span><br><span class="line">  props: &#123; id: &quot;container&quot; &#125;,</span><br><span class="line">  children: [</span><br><span class="line">    &#123;</span><br><span class="line">      type: &quot;p&quot;,</span><br><span class="line">      props: null,</span><br><span class="line">      children: [</span><br><span class="line">        &#123; type: &quot;text&quot;, props: &#123; textContent: &quot;Hello React&quot; &#125; &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const after = &#123;</span><br><span class="line">  type: &quot;div&quot;,</span><br><span class="line">  props: &#123; id: &quot;container&quot; &#125;,</span><br><span class="line">  children: [</span><br><span class="line">    &#123;</span><br><span class="line">      type: &quot;p&quot;,</span><br><span class="line">      props: null,</span><br><span class="line">      children: [</span><br><span class="line">        &#123; type: &quot;text&quot;, props: &#123; textContent: &quot;Hello Angular&quot; &#125; &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-创建-Virtual-DOM"><a href="#5-创建-Virtual-DOM" class="headerlink" title="5. 创建 Virtual DOM"></a>5. 创建 Virtual DOM</h2><p>在 React 代码执行前，JSX 会被 Babel 转换为 React.createElement 方法的调用，在调用 createElement 方法时会传入元素的类型，元素的属性，以及元素的子元素，createElement 方法的返回值为构建好的 Virtual DOM 对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  type: &quot;div&quot;,</span><br><span class="line">  props: null,</span><br><span class="line">  children: [&#123;type: &quot;text&quot;, props: &#123;textContent: &quot;Hello&quot;&#125;&#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 创建 Virtual DOM</span><br><span class="line"> * @param &#123;string&#125; type 类型</span><br><span class="line"> * @param &#123;object | null&#125; props 属性</span><br><span class="line"> * @param  &#123;createElement[]&#125; children 子元素</span><br><span class="line"> * @return &#123;object&#125; Virtual DOM</span><br><span class="line"> */</span><br><span class="line">function createElement (type, props, ...children) &#123;</span><br><span class="line">	return &#123;</span><br><span class="line">    type,</span><br><span class="line">    props,</span><br><span class="line">    children</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从 createElement 方法的第三个参数开始就都是子元素了，在定义 createElement 方法时，通过 <code>...children</code> 将所有的子元素放置到 children 数组中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">const virtualDOM = (</span><br><span class="line">  &lt;div className=&quot;container&quot;&gt;</span><br><span class="line">    &lt;h1&gt;你好 Tiny React&lt;/h1&gt;</span><br><span class="line">    &lt;h2&gt;(编码必杀技)&lt;/h2&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      嵌套1 &lt;div&gt;嵌套 1.1&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;h3&gt;(观察: 这个将会被改变)&lt;/h3&gt;</span><br><span class="line">    &#123;2 == 1 &amp;&amp; &lt;div&gt;如果2和1相等渲染当前内容&lt;/div&gt;&#125;</span><br><span class="line">    &#123;2 == 2 &amp;&amp; &lt;div&gt;2&lt;/div&gt;&#125;</span><br><span class="line">    &lt;span&gt;这是一段内容&lt;/span&gt;</span><br><span class="line">    &lt;button onClick=&#123;() =&gt; alert(&quot;你好&quot;)&#125;&gt;点击我&lt;/button&gt;</span><br><span class="line">    &lt;h3&gt;这个将会被删除&lt;/h3&gt;</span><br><span class="line">    2, 3</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">)</span><br><span class="line">console.log(virtualDOM)</span><br></pre></td></tr></table></figure>

<p>通过以上代码测试，发现返回的 Virtual DOM 存在一些问题，第一个问题是文本节点被直接放入到了数组中</p>
<img src="./images2/2.png" width="50%"/>

<p>而我们期望是文本节点应该是这样的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">children: [</span><br><span class="line">  &#123;</span><br><span class="line">    type: &quot;text&quot;,</span><br><span class="line">    props: &#123;</span><br><span class="line">      textContent: &quot;React is great&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>通过以下代码对 Virtual DOM 进行改造，重新构建 Virtual DOM。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将原有 children 拷贝一份 不要在原有数组上进行操作</span></span><br><span class="line"><span class="keyword">const</span> childElements = [].<span class="title function_">concat</span>(...children).<span class="title function_">map</span>(<span class="function"><span class="params">child</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 判断 child 是否是对象类型</span></span><br><span class="line">  <span class="keyword">if</span> (child <span class="keyword">instanceof</span> <span class="title class_">Object</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果是 什么都不需要做 直接返回即可</span></span><br><span class="line">    <span class="keyword">return</span> child</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果不是对象就是文本 手动调用 createElement 方法将文本转换为 Virtual DOM</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">createElement</span>(<span class="string">&quot;text&quot;</span>, &#123; <span class="attr">textContent</span>: child &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">  type,</span><br><span class="line">  props,</span><br><span class="line">  <span class="attr">children</span>: childElements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="./images2/3.png" width="50%"/>

<p>通过观察返回的 Virtual DOM，文本节点已经被转化成了对象类型的 Virtual DOM，但是布尔值也被当做文本节点被转化了，在 JSX 中，如果 Virtual DOM 被转化为了布尔值或者null，是不应该被更新到真实 DOM 中的，所以接下来要做的事情就是清除 Virtual DOM 中的布尔值和null。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 由于 map 方法无法从数据中刨除元素, 所以此处将 map 方法更改为 reduce 方法</span><br><span class="line">const childElements = [].concat(...children).reduce((result, child) =&gt; &#123;</span><br><span class="line">  // 判断子元素类型 刨除 null true false</span><br><span class="line">  if (child != null &amp;&amp; child != false &amp;&amp; child != true) &#123;</span><br><span class="line">    if (child instanceof Object) &#123;</span><br><span class="line">      result.push(child)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      result.push(createElement(&quot;text&quot;, &#123; textContent: child &#125;))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // 将需要保留的 Virtual DOM 放入 result 数组</span><br><span class="line">  return result</span><br><span class="line">&#125;, [])</span><br></pre></td></tr></table></figure>

<p>在 React 组件中，可以通过 props.children 获取子元素，所以还需要将子元素存储在 props 对象中。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">  type,</span><br><span class="line">  <span class="attr">props</span>: <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123; <span class="attr">children</span>: childElements &#125;, props),</span><br><span class="line">  <span class="attr">children</span>: childElements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-渲染-Virtual-DOM-对象为-DOM-对象"><a href="#6-渲染-Virtual-DOM-对象为-DOM-对象" class="headerlink" title="6. 渲染 Virtual DOM 对象为 DOM 对象"></a>6. 渲染 Virtual DOM 对象为 DOM 对象</h2><p>通过调用 render 方法可以将 Virtual DOM 对象更新为真实 DOM 对象。</p>
<p>在更新之前需要确定是否存在旧的 Virtual DOM，如果存在需要比对差异，如果不存在可以直接将 Virtual DOM 转换为 DOM 对象。 </p>
<p>目前先只考虑不存在旧的 Virtual DOM 的情况，就是说先直接将 Virtual DOM 对象更新为真实 DOM 对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// render.js</span><br><span class="line">export default function render(virtualDOM, container, oldDOM = container.firstChild) &#123;</span><br><span class="line">  // 在 diff 方法内部判断是否需要对比 对比也好 不对比也好 都在 diff 方法中进行操作  </span><br><span class="line">  diff(virtualDOM, container, oldDOM)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// diff.js</span><br><span class="line">import mountElement from &quot;./mountElement&quot;</span><br><span class="line"></span><br><span class="line">export default function diff(virtualDOM, container, oldDOM) &#123;</span><br><span class="line">  // 判断 oldDOM 是否存在</span><br><span class="line">  if (!oldDOM) &#123;</span><br><span class="line">    // 如果不存在 不需要对比 直接将 Virtual DOM 转换为真实 DOM</span><br><span class="line">    mountElement(virtualDOM, container)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在进行 virtual DOM 转换之前还需要确定 Virtual DOM 的类 Component VS Native Element。</p>
<p>类型不同需要做不同的处理 如果是 Native Element 直接转换。</p>
<p>如果是组件 还需要得到组件实例对象 通过组件实例对象获取组件返回的 virtual DOM 然后再进行转换。</p>
<p>目前先只考虑 Native Element 的情况。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// mountElement.js</span><br><span class="line">import mountNativeElement from &quot;./mountNativeElement&quot;</span><br><span class="line"></span><br><span class="line">export default function mountElement(virtualDOM, container) &#123;</span><br><span class="line">  // 通过调用 mountNativeElement 方法转换 Native Element</span><br><span class="line">  mountNativeElement(virtualDOM, container)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// mountNativeElement.js</span><br><span class="line">import createDOMElement from &quot;./createDOMElement&quot;</span><br><span class="line"></span><br><span class="line">export default function mountNativeElement(virtualDOM, container) &#123;</span><br><span class="line">  const newElement = createDOMElement(virtualDOM)</span><br><span class="line">  container.appendChild(newElement)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// createDOMElement.js</span><br><span class="line">import mountElement from &quot;./mountElement&quot;</span><br><span class="line">import updateElementNode from &quot;./updateElementNode&quot;</span><br><span class="line"></span><br><span class="line">export default function createDOMElement(virtualDOM) &#123;</span><br><span class="line">  let newElement = null</span><br><span class="line">  if (virtualDOM.type === &quot;text&quot;) &#123;</span><br><span class="line">    // 创建文本节点</span><br><span class="line">    newElement = document.createTextNode(virtualDOM.props.textContent)</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    // 创建元素节点</span><br><span class="line">    newElement = document.createElement(virtualDOM.type)</span><br><span class="line">    // 更新元素属性</span><br><span class="line">    updateElementNode(newElement, virtualDOM)</span><br><span class="line">  &#125;</span><br><span class="line">  // 递归渲染子节点</span><br><span class="line">  virtualDOM.children.forEach(child =&gt; &#123;</span><br><span class="line">    // 因为不确定子元素是 NativeElement 还是 Component 所以调用 mountElement 方法进行确定</span><br><span class="line">    mountElement(child, newElement)</span><br><span class="line">  &#125;)</span><br><span class="line">  return newElement</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="7-为元素节点添加属性"><a href="#7-为元素节点添加属性" class="headerlink" title="7. 为元素节点添加属性"></a>7. 为元素节点添加属性</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// createDOMElement.js</span><br><span class="line">// 看看节点类型是文本类型还是元素类型</span><br><span class="line">if (virtualDOM.type === &quot;text&quot;) &#123;</span><br><span class="line">  // 创建文本节点 设置节点内容</span><br><span class="line">  newElement = document.createTextNode(virtualDOM.props.textContent)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  // 根据 Virtual DOM type 属性值创建 DOM 元素</span><br><span class="line">  newElement = document.createElement(virtualDOM.type)</span><br><span class="line">  // 为元素设置属性</span><br><span class="line">  updateElementNode(newElement, virtualDOM)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">export default function updateElementNode(element, virtualDOM) &#123;</span><br><span class="line">  // 获取要解析的 VirtualDOM 对象中的属性对象</span><br><span class="line">  const newProps = virtualDOM.props</span><br><span class="line">  // 将属性对象中的属性名称放到一个数组中并循环数组</span><br><span class="line">  Object.keys(newProps).forEach(propName =&gt; &#123;</span><br><span class="line">    const newPropsValue = newProps[propName]</span><br><span class="line">    // 考虑属性名称是否以 on 开头 如果是就表示是个事件属性 onClick -&gt; click</span><br><span class="line">    if (propName.slice(0, 2) === &quot;on&quot;) &#123;</span><br><span class="line">      const eventName = propName.toLowerCase().slice(2)</span><br><span class="line">      element.addEventListener(eventName, newPropsValue)</span><br><span class="line">      // 如果属性名称是 value 或者 checked 需要通过 [] 的形式添加</span><br><span class="line">    &#125; else if (propName === &quot;value&quot; || propName === &quot;checked&quot;) &#123;</span><br><span class="line">      element[propName] = newPropsValue</span><br><span class="line">      // 刨除 children 因为它是子元素 不是属性</span><br><span class="line">    &#125; else if (propName !== &quot;children&quot;) &#123;</span><br><span class="line">      // className 属性单独处理 不直接在元素上添加 class 属性是因为 class 是 JavaScript 中的关键字</span><br><span class="line">      if (propName === &quot;className&quot;) &#123;</span><br><span class="line">        element.setAttribute(&quot;class&quot;, newPropsValue)</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        // 普通属性</span><br><span class="line">        element.setAttribute(propName, newPropsValue)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-渲染组件"><a href="#8-渲染组件" class="headerlink" title="8. 渲染组件"></a>8. 渲染组件</h2><h3 id="8-1-函数组件"><a href="#8-1-函数组件" class="headerlink" title="8.1 函数组件"></a>8.1 函数组件</h3><p>在渲染组件之前首先要明确的是，组件的 Virtual DOM 类型值为函数，函数组件和类组件都是这样的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 原始组件</span><br><span class="line">const Heart = () =&gt; &lt;span&gt;&amp;hearts;&lt;/span&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Heart /&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 组件的 Virtual DOM</span><br><span class="line">&#123;</span><br><span class="line">  type: f function() &#123;&#125;,</span><br><span class="line">  props: &#123;&#125;</span><br><span class="line">  children: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在渲染组件时，要先将 Component 与 Native Element 区分开，如果是 Native Element 可以直接开始渲染，如果是组件，特别处理。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// mountElement.js</span><br><span class="line">export default function mountElement(virtualDOM, container) &#123;</span><br><span class="line">  // 无论是类组件还是函数组件 其实本质上都是函数 </span><br><span class="line">  // 如果 Virtual DOM 的 type 属性值为函数 就说明当前这个 Virtual DOM 为组件</span><br><span class="line">  if (isFunction(virtualDOM)) &#123;</span><br><span class="line">    // 如果是组件 调用 mountComponent 方法进行组件渲染</span><br><span class="line">    mountComponent(virtualDOM, container)</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    mountNativeElement(virtualDOM, container)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Virtual DOM 是否为函数类型</span><br><span class="line">export function isFunction(virtualDOM) &#123;</span><br><span class="line">  return virtualDOM &amp;&amp; typeof virtualDOM.type === &quot;function&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 mountComponent 方法中再进行函数组件和类型的区分，然后再分别进行处理。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">// mountComponent.js</span><br><span class="line">import mountNativeElement from &quot;./mountNativeElement&quot;</span><br><span class="line"></span><br><span class="line">export default function mountComponent(virtualDOM, container) &#123;</span><br><span class="line">  // 存放组件调用后返回的 Virtual DOM 的容器</span><br><span class="line">  let nextVirtualDOM = null</span><br><span class="line">  // 区分函数型组件和类组件</span><br><span class="line">  if (isFunctionalComponent(virtualDOM)) &#123;</span><br><span class="line">    // 函数组件 调用 buildFunctionalComponent 方法处理函数组件</span><br><span class="line">    nextVirtualDOM = buildFunctionalComponent(virtualDOM)</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    // 类组件</span><br><span class="line">  &#125;</span><br><span class="line">  // 判断得到的 Virtual Dom 是否是组件</span><br><span class="line">  if (isFunction(nextVirtualDOM)) &#123;</span><br><span class="line">    // 如果是组件 继续调用 mountComponent 解剖组件</span><br><span class="line">    mountComponent(nextVirtualDOM, container)</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    // 如果是 Navtive Element 就去渲染</span><br><span class="line">    mountNativeElement(nextVirtualDOM, container)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Virtual DOM 是否为函数型组件</span><br><span class="line">// 条件有两个: 1. Virtual DOM 的 type 属性值为函数 2. 函数的原型对象中不能有render方法</span><br><span class="line">// 只有类组件的原型对象中有render方法 </span><br><span class="line">export function isFunctionalComponent(virtualDOM) &#123;</span><br><span class="line">  const type = virtualDOM &amp;&amp; virtualDOM.type</span><br><span class="line">  return (</span><br><span class="line">    type &amp;&amp; isFunction(virtualDOM) &amp;&amp; !(type.prototype &amp;&amp; type.prototype.render)</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 函数组件处理 </span><br><span class="line">function buildFunctionalComponent(virtualDOM) &#123;</span><br><span class="line">  // 通过 Virtual DOM 中的 type 属性获取到组件函数并调用</span><br><span class="line">  // 调用组件函数时将 Virtual DOM 对象中的 props 属性传递给组件函数 这样在组件中就可以通过 props 属性获取数据了</span><br><span class="line">  // 组件返回要渲染的 Virtual DOM</span><br><span class="line">  return virtualDOM &amp;&amp; virtualDOM.type(virtualDOM.props || &#123;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-2-类组件"><a href="#8-2-类组件" class="headerlink" title="8.2 类组件"></a>8.2 类组件</h3><p>类组件本身也是 Virtual DOM，可以通过 Virtual DOM 中的 type 属性值确定当前要渲染的组件是类组件还是函数组件。</p>
<p>在确定当前要渲染的组件为类组件以后，需要实例化类组件得到类组件实例对象，通过类组件实例对象调用类组件中的 render 方法，获取组件要渲染的 Virtual DOM。</p>
<p>类组件需要继承 Component 父类，子类需要通过 super 方法将自身的 props 属性传递给 Component 父类，父类会将 props 属性挂载为父类属性，子类继承了父类，自己本身也就自然拥有props属性了。这样做的好处是当 props 发生更新后，父类可以根据更新后的 props 帮助子类更新视图。</p>
<p>假设以下代码就是我们要渲染的类组件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Alert extends TinyReact.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    // 将 props 传递给父类 子类继承父类的 props 子类自然就有 props 数据了</span><br><span class="line">    // 否则 props 仅仅是 constructor 函数的参数而已</span><br><span class="line">    // 将 props 传递给父类的好处是 当 props 发生更改时 父类可以帮助更新 props 更新组件视图</span><br><span class="line">    super(props)</span><br><span class="line">    this.state = &#123;</span><br><span class="line">      title: &quot;default title&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h2&gt;&#123;this.state.title&#125;&lt;/h2&gt;</span><br><span class="line">        &lt;p&gt;&#123;this.props.message&#125;&lt;/p&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TinyReact.render(&lt;Alert message=&quot;Hello React&quot; /&gt;, root)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// Component.js 父类 Component 实现</span><br><span class="line">export default class Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    this.props = props</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 mountComponent 方法中通过调用 buildStatefulComponent 方法得到类组件要渲染的 Virtual DOM</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// mountComponent.js</span><br><span class="line">export default function mountComponent(virtualDOM, container) &#123;</span><br><span class="line">  let nextVirtualDOM = null</span><br><span class="line">  // 区分函数型组件和类组件</span><br><span class="line">  if (isFunctionalComponent(virtualDOM)) &#123;</span><br><span class="line">    // 函数组件</span><br><span class="line">    nextVirtualDOM = buildFunctionalComponent(virtualDOM)</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    // 类组件</span><br><span class="line">    nextVirtualDOM = buildStatefulComponent(virtualDOM)</span><br><span class="line">  &#125;</span><br><span class="line">  // 判断得到的 Virtual Dom 是否是组件</span><br><span class="line">  if (isFunction(nextVirtualDOM)) &#123;</span><br><span class="line">    mountComponent(nextVirtualDOM, container)</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    mountNativeElement(nextVirtualDOM, container)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 处理类组件</span><br><span class="line">function buildStatefulComponent(virtualDOM) &#123;</span><br><span class="line">  // 实例化类组件 得到类组件实例对象 并将 props 属性传递进类组件</span><br><span class="line">  const component = new virtualDOM.type(virtualDOM.props)</span><br><span class="line">  // 调用类组件中的render方法得到要渲染的 Virtual DOM</span><br><span class="line">  const nextVirtualDOM = component.render()</span><br><span class="line">  // 返回要渲染的 Virtual DOM</span><br><span class="line">  return nextVirtualDOM</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9-Virtual-DOM-比对"><a href="#9-Virtual-DOM-比对" class="headerlink" title="9. Virtual DOM 比对"></a>9. Virtual DOM 比对</h2><p>在进行 Virtual DOM 比对时，需要用到更新后的 Virtual DOM 和更新前的 Virtual DOM，更新后的 Virtual DOM 目前我们可以通过 render 方法进行传递，现在的问题是更新前的 Virtual DOM 要如何获取呢？</p>
<p>对于更新前的 Virtual DOM，对应的其实就是已经在页面中显示的真实 DOM 对象。既然是这样，那么我们在创建真实DOM对象时，就可以将 Virtual DOM 添加到真实 DOM 对象的属性中。在进行 Virtual DOM 对比之前，就可以通过真实 DOM 对象获取其对应的 Virtual DOM 对象了，其实就是通过render方法的第三个参数获取的，container.firstChild。</p>
<p>在创建真实 DOM 对象时为其添加对应的 Virtual DOM 对象</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// mountElement.js</span><br><span class="line">import mountElement from &quot;./mountElement&quot;</span><br><span class="line"></span><br><span class="line">export default function mountNativeElement(virtualDOM, container) &#123;</span><br><span class="line">  // 将 Virtual DOM 挂载到真实 DOM 对象的属性中 方便在对比时获取其 Virtual DOM</span><br><span class="line">  newElement._virtualDOM = virtualDOM</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="./images2/8.png" width="80%" style="margin-bottom: 30px"/>

<h3 id="9-1-Virtual-DOM-类型相同"><a href="#9-1-Virtual-DOM-类型相同" class="headerlink" title="9.1 Virtual DOM 类型相同"></a>9.1 Virtual DOM 类型相同</h3><p>Virtual DOM 类型相同，如果是元素节点，就对比元素节点属性是否发生变化，如果是文本节点就对比文本节点内容是否发生变化</p>
<p>要实现对比，需要先从已存在 DOM 对象中获取其对应的 Virtual DOM 对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// diff.js</span><br><span class="line">// 获取未更新前的 Virtual DOM</span><br><span class="line">const oldVirtualDOM = oldDOM &amp;&amp; oldDOM._virtualDOM</span><br></pre></td></tr></table></figure>

<p>判断 oldVirtualDOM 是否存在， 如果存在则继续判断要对比的 Virtual DOM 类型是否相同，如果类型相同判断节点类型是否是文本，如果是文本节点对比，就调用 updateTextNode 方法，如果是元素节点对比就调用 setAttributeForElement 方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// diff.js</span><br><span class="line">else if (oldVirtualDOM &amp;&amp; virtualDOM.type === oldVirtualDOM.type) &#123;</span><br><span class="line">  if (virtualDOM.type === &quot;text&quot;) &#123;</span><br><span class="line">    // 文本节点 对比文本内容是否发生变化</span><br><span class="line">    updateTextNode(virtualDOM, oldVirtualDOM, oldDOM)</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    // 元素节点 对比元素属性是否发生变化</span><br><span class="line">    setAttributeForElement(oldDOM, virtualDOM, oldVirtualDOM)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>updateTextNode 方法用于对比文本节点内容是否发生变化，如果发生变化则更新真实 DOM 对象中的内容，既然真实 DOM 对象发生了变化，还要将最新的 Virtual DOM 同步给真实 DOM 对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function updateTextNode(virtualDOM, oldVirtualDOM, oldDOM) &#123;</span><br><span class="line">  // 如果文本节点内容不同</span><br><span class="line">  if (virtualDOM.props.textContent !== oldVirtualDOM.props.textContent) &#123;</span><br><span class="line">    // 更新真实 DOM 对象中的内容</span><br><span class="line">    oldDOM.textContent = virtualDOM.props.textContent</span><br><span class="line">  &#125;</span><br><span class="line">  // 同步真实 DOM 对应的 Virtual DOM</span><br><span class="line">  oldDOM._virtualDOM = virtualDOM</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>setAttributeForElement 方法用于设置&#x2F;更新元素节点属性</p>
<p>思路是先分别获取更新后的和更新前的 Virtual DOM 中的 props 属性，循环新 Virtual DOM 中的 props 属性，通过对比看一下新 Virtual DOM 中的属性值是否发生了变化，如果发生变化 需要将变化的值更新到真实 DOM 对象中</p>
<p>再循环未更新前的 Virtual DOM 对象，通过对比看看新的 Virtual DOM 中是否有被删除的属性，如果存在删除的属性 需要将 DOM 对象中对应的属性也删除掉</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">// updateNodeElement.js</span><br><span class="line">export default function updateNodeElement(</span><br><span class="line">  newElement,</span><br><span class="line">  virtualDOM,</span><br><span class="line">  oldVirtualDOM = &#123;&#125;</span><br><span class="line">) &#123;</span><br><span class="line">  // 获取节点对应的属性对象</span><br><span class="line">  const newProps = virtualDOM.props || &#123;&#125;</span><br><span class="line">  const oldProps = oldVirtualDOM.props || &#123;&#125;</span><br><span class="line">  Object.keys(newProps).forEach(propName =&gt; &#123;</span><br><span class="line">    // 获取属性值</span><br><span class="line">    const newPropsValue = newProps[propName]</span><br><span class="line">    const oldPropsValue = oldProps[propName]</span><br><span class="line">    if (newPropsValue !== oldPropsValue) &#123;</span><br><span class="line">      // 判断属性是否是否事件属性 onClick -&gt; click</span><br><span class="line">      if (propName.slice(0, 2) === &quot;on&quot;) &#123;</span><br><span class="line">        // 事件名称</span><br><span class="line">        const eventName = propName.toLowerCase().slice(2)</span><br><span class="line">        // 为元素添加事件</span><br><span class="line">        newElement.addEventListener(eventName, newPropsValue)</span><br><span class="line">        // 删除原有的事件的事件处理函数</span><br><span class="line">        if (oldPropsValue) &#123;</span><br><span class="line">          newElement.removeEventListener(eventName, oldPropsValue)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; else if (propName === &quot;value&quot; || propName === &quot;checked&quot;) &#123;</span><br><span class="line">        newElement[propName] = newPropsValue</span><br><span class="line">      &#125; else if (propName !== &quot;children&quot;) &#123;</span><br><span class="line">        if (propName === &quot;className&quot;) &#123;</span><br><span class="line">          newElement.setAttribute(&quot;class&quot;, newPropsValue)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          newElement.setAttribute(propName, newPropsValue)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  // 判断属性被删除的情况</span><br><span class="line">  Object.keys(oldProps).forEach(propName =&gt; &#123;</span><br><span class="line">    const newPropsValue = newProps[propName]</span><br><span class="line">    const oldPropsValue = oldProps[propName]</span><br><span class="line">    if (!newPropsValue) &#123;</span><br><span class="line">      // 属性被删除了</span><br><span class="line">      if (propName.slice(0, 2) === &quot;on&quot;) &#123;</span><br><span class="line">        const eventName = propName.toLowerCase().slice(2)</span><br><span class="line">        newElement.removeEventListener(eventName, oldPropsValue)</span><br><span class="line">      &#125; else if (propName !== &quot;children&quot;) &#123;</span><br><span class="line">        newElement.removeAttribute(propName)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上对比的仅仅是最上层元素，上层元素对比完成以后还需要递归对比子元素</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">else if (oldVirtualDOM &amp;&amp; virtualDOM.type === oldVirtualDOM.type) &#123;</span><br><span class="line">    // 递归对比 Virtual DOM 的子元素</span><br><span class="line">    virtualDOM.children.forEach((child, i) =&gt; &#123;</span><br><span class="line">      diff(child, oldDOM, oldDOM.childNodes[i])</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<img src="./images2/7.png"/>

<h3 id="9-2-Virtual-DOM-类型不同"><a href="#9-2-Virtual-DOM-类型不同" class="headerlink" title="9.2 Virtual DOM 类型不同"></a>9.2 Virtual DOM 类型不同</h3><p>当对比的元素节点类型不同时，就不需要继续对比了，直接使用新的 Virtual DOM 创建 DOM 对象，用新的 DOM 对象直接替换旧的 DOM 对象。当前这种情况要将组件刨除，组件要被单独处理。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// diff.js</span><br><span class="line">else if (</span><br><span class="line">  // 如果 Virtual DOM 类型不一样</span><br><span class="line">  virtualDOM.type !== oldVirtualDOM.type &amp;&amp;</span><br><span class="line">  // 并且 Virtual DOM 不是组件 因为组件要单独进行处理</span><br><span class="line">  typeof virtualDOM.type !== &quot;function&quot;</span><br><span class="line">) &#123;</span><br><span class="line">  // 根据 Virtual DOM 创建真实 DOM 元素</span><br><span class="line">  const newDOMElement = createDOMElement(virtualDOM)</span><br><span class="line">  // 用创建出来的真实 DOM 元素 替换旧的 DOM 元素</span><br><span class="line">  oldDOM.parentNode.replaceChild(newDOMElement, oldDOM)</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h3 id="9-3-删除节点"><a href="#9-3-删除节点" class="headerlink" title="9.3 删除节点"></a>9.3 删除节点</h3><p>删除节点发生在节点更新以后并且发生在同一个父节点下的所有子节点身上。</p>
<p>在节点更新完成以后，如果旧节点对象的数量多于新 VirtualDOM 节点的数量，就说明有节点需要被删除。</p>
<img src="./images2/5.png" width="40%" align="left"/>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 获取就节点的数量</span><br><span class="line">let oldChildNodes = oldDOM.childNodes</span><br><span class="line">// 如果旧节点的数量多于要渲染的新节点的长度</span><br><span class="line">if (oldChildNodes.length &gt; virtualDOM.children.length) &#123;</span><br><span class="line">  for (</span><br><span class="line">    let i = oldChildNodes.length - 1;</span><br><span class="line">    i &gt; virtualDOM.children.length - 1;</span><br><span class="line">    i--</span><br><span class="line">  ) &#123;</span><br><span class="line">    oldDOM.removeChild(oldChildNodes[i])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-4-类组件状态更新"><a href="#9-4-类组件状态更新" class="headerlink" title="9.4 类组件状态更新"></a>9.4 类组件状态更新</h3><p>以下代码是要更新状态的类组件，在类组件的 state 对象中有默认的 title 状态，点击 change title 按钮调用 handleChange 方法，在 handleChange 方法中调用 this.setState 方法更改 title 的状态值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Alert extends TinyReact.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props)</span><br><span class="line">    this.state = &#123;</span><br><span class="line">      title: &quot;default title&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    // 更改 handleChange 方法中的 this 指向 让 this 指向类实例对象</span><br><span class="line">    this.handleChange = this.handleChange.bind(this)</span><br><span class="line">  &#125;</span><br><span class="line">  handleChange() &#123;</span><br><span class="line">    // 调用父类中的 setState 方法更改状态</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      title: &quot;changed title&quot;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h2&gt;&#123;this.state.title&#125;&lt;/h2&gt;</span><br><span class="line">        &lt;p&gt;&#123;this.props.message&#125;&lt;/p&gt;</span><br><span class="line">        &lt;button onClick=&#123;this.handleChange&#125;&gt;change title&lt;/button&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>setState 方法是定义在父类 Component 中的，该方法的作用是更改子类的 state，产生一个全新的 state 对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// Component.js</span><br><span class="line">export default class Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    this.props = props</span><br><span class="line">  &#125;</span><br><span class="line">  setState (state) &#123;</span><br><span class="line">    // setState 方法被子类调用 此处this指向子类实例对象</span><br><span class="line">    // 所以改变的是子类的 state 对象</span><br><span class="line">    this.state = Object.assign(&#123;&#125;, this.state, state)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在子类已经可以调用父类的 setState 方法更改状态值了，当组件的 state 对象发生更改时，要调用 render 方法更新组件视图。</p>
<p>在更新组件之前，要使用更新的 Virtual DOM 对象和未更新的 Virtual DOM 进行对比找出更新的部分，达到 DOM 最小化操作的目的。</p>
<p>在 setState 方法中可以通过调用 this.render 方法获取更新后的 Virtual DOM，由于 setState 方法被子类调用，this 指向子类，所以此处调用的是子类的 render 方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// Component.js</span><br><span class="line">setState(state) &#123;</span><br><span class="line">  // setState 方法被子类调用 此处this指向子类</span><br><span class="line">  // 所以改变的是子类的 state</span><br><span class="line">  this.state = Object.assign(&#123;&#125;, this.state, state)</span><br><span class="line">  // 通过调用 render 方法获取最新的 Virtual DOM</span><br><span class="line">  let virtualDOM = this.render()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要实现对比，还需要获取未更新前的 Virtual DOM，按照之前的经验，我们可以从 DOM 对象中获取其对应的 Virtual  DOM 对象，未更新前的 DOM 对象实际上就是现在在页面中显示的 DOM 对象，我们只要能获取到这个 DOM 对象就可以获取到其对应的 Virtual DOM 对象了。</p>
<p>页面中的 DOM 对象要怎样获取呢？页面中的 DOM 对象是通过 mountNativeElement 方法挂载到页面中的，所以我们只需要在这个方法中调用 Component 类中的方法就可以将 DOM 对象保存在 Component 类中了。在子类调用 setState 方法的时候，在 setState 方法中再调用另一个获取 DOM 对象的方法就可以获取到之前保存的 DOM 对象了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// Component.js</span><br><span class="line">// 保存 DOM 对象的方法</span><br><span class="line">setDOM(dom) &#123;</span><br><span class="line">  this._dom = dom</span><br><span class="line">&#125;</span><br><span class="line">// 获取 DOM 对象的方法</span><br><span class="line">getDOM() &#123;</span><br><span class="line">  return this._dom</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们要研究一下在 mountNativeElement 方法中如何才能调用到 setDOM 方法，要调用 setDOM 方法，必须要得到类的实例对象，所以目前的问题就是如何在 mountNativeElement 方法中得到类的实例对象，这个类指的不是Component类，因为我们在代码中并不是直接实例化的Component类，而是实例化的它的子类，由于子类继承了父类，所以在子类的实例对象中也是可以调用到 setDOM 方法的。</p>
<p>mountNativeElement 方法接收最新的 Virtual DOM 对象，如果这个 Virtual DOM 对象是类组件产生的，在产生这个 Virtual DOM 对象时一定会先得到这个类的实例对象，然后再调用实例对象下面的 render 方法进行获取。我们可以在那个时候将类组件实例对象添加到 Virtual DOM 对象的属性中，而这个 Virtual DOM 对象最终会传递给 mountNativeElement  方法，这样我们就可以在 mountNativeElement 方法中获取到组件的实例对象了，既然类组件的实例对象获取到了，我们就可以调用 setDOM 方法了。</p>
<p>在 buildClassComponent 方法中为 Virtual DOM 对象添加 component 属性， 值为类组件的实例对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function buildClassComponent(virtualDOM) &#123;</span><br><span class="line">  const component = new virtualDOM.type(virtualDOM.props)</span><br><span class="line">  const nextVirtualDOM = component.render()</span><br><span class="line">  nextVirtualDOM.component = component</span><br><span class="line">  return nextVirtualDOM</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 mountNativeElement 方法中获取组件实例对象，通过实例调用调用 setDOM 方法保存 DOM 对象，方便在对比时通过它获取它的 Virtual DOM 对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">export default function mountNativeElement(virtualDOM, container) &#123;</span><br><span class="line">  // 获取组件实例对象</span><br><span class="line">  const component = virtualDOM.component</span><br><span class="line">  // 如果组件实例对象存在</span><br><span class="line">  if (component) &#123;</span><br><span class="line">    // 保存 DOM 对象</span><br><span class="line">    component.setDOM(newElement)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来在 setState 方法中就可以调用 getDOM 方法获取 DOM 对象了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">setState(state) &#123;</span><br><span class="line">  this.state = Object.assign(&#123;&#125;, this.state, state)</span><br><span class="line">  let virtualDOM = this.render()</span><br><span class="line">  // 获取页面中正在显示的 DOM 对象 通过它可以获取其对象的 Virtual DOM 对象</span><br><span class="line">  let oldDOM = this.getDOM()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在更新前的 Virtual DOM 对象和更新后的 Virtual DOM 对象就都已经获取到了，接下来还要获取到真实 DOM 对象父级容器对象，因为在调用 diff 方法进行对比的时候需要用到</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">setState(state) &#123;</span><br><span class="line">  this.state = Object.assign(&#123;&#125;, this.state, state)</span><br><span class="line">  let virtualDOM = this.render()</span><br><span class="line">  let oldDOM = this.getDOM()</span><br><span class="line">  // 获取真实 DOM 对象父级容器对象</span><br><span class="line">  let container = oldDOM.parentNode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来就可以调用 diff 方法进行比对了，比对后会按照我们之前写好的逻辑进行 DOM 对象更新，我们就可以在页面中看到效果了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">setState(state) &#123;</span><br><span class="line">    this.state = Object.assign(&#123;&#125;, this.state, state)</span><br><span class="line">    let virtualDOM = this.render()</span><br><span class="line">    let oldDOM = this.getDOM()</span><br><span class="line">    let container = oldDOM.parentNode</span><br><span class="line">    // 比对</span><br><span class="line">    diff(virtualDOM, container, oldDOM)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-5-组件更新"><a href="#9-5-组件更新" class="headerlink" title="9.5 组件更新"></a>9.5 组件更新</h3><p>在 diff 方法中判断要更新的 Virtual DOM 是否是组件。</p>
<p>如果是组件再判断要更新的组件和未更新前的组件是否是同一个组件，如果不是同一个组件就不需要做组件更新操作，直接调用 mountElement 方法将组件返回的 Virtual DOM 添加到页面中。</p>
<p>如果是同一个组件，就执行更新组件操作，其实就是将最新的 props 传递到组件中，再调用组件的render方法获取组件返回的最新的 Virtual DOM 对象，再将 Virtual DOM 对象传递给 diff 方法，让 diff 方法找出差异，从而将差异更新到真实 DOM 对象中。</p>
<p>在更新组件的过程中还要在不同阶段调用其不同的组件生命周期函数。</p>
<p>在 diff 方法中判断要更新的 Virtual DOM 是否是组件，如果是组件又分为多种情况，新增 diffComponent 方法进行处理</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">else if (typeof virtualDOM.type === &quot;function&quot;) &#123;</span><br><span class="line">  // 要更新的是组件</span><br><span class="line">  // 1) 组件本身的 virtualDOM 对象 通过它可以获取到组件最新的 props</span><br><span class="line">  // 2) 要更新的组件的实例对象 通过它可以调用组件的生命周期函数 可以更新组件的 props 属性 可以获取到组件返回的最新的 Virtual DOM</span><br><span class="line">  // 3) 要更新的 DOM 象 在更新组件时 需要在已有DOM对象的身上进行修改 实现DOM最小化操作 获取旧的 Virtual DOM 对象</span><br><span class="line">  // 4) 如果要更新的组件和旧组件不是同一个组件 要直接将组件返回的 Virtual DOM 显示在页面中 此时需要 container 做为父级容器</span><br><span class="line">  diffComponent(virtualDOM, oldComponent, oldDOM, container)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 diffComponent 方法中判断要更新的组件是未更新前的组件是否是同一个组件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// diffComponent.js</span><br><span class="line">export default function diffComponent(virtualDOM, oldComponent, oldDOM, container) &#123;</span><br><span class="line">  // 判断要更新的组件和未更新的组件是否是同一个组件 只需要确定两者使用的是否是同一个构造函数就可以了</span><br><span class="line">  if (isSameComponent(virtualDOM, oldComponent)) &#123;</span><br><span class="line">    // 属同一个组件 做组件更新  </span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    // 不是同一个组件 直接将组件内容显示在页面中</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// virtualDOM.type 更新后的组件构造函数</span><br><span class="line">// oldComponent.constructor 未更新前的组件构造函数</span><br><span class="line">// 两者等价就表示是同一组件</span><br><span class="line">function isSameComponent(virtualDOM, oldComponent) &#123;</span><br><span class="line">  return oldComponent &amp;&amp; virtualDOM.type === oldComponent.constructor</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果不是同一个组件的话，就不需要执行更新组件的操作，直接将组件内容显示在页面中，替换原有内容</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// diffComponent.js</span><br><span class="line">else &#123;</span><br><span class="line">  // 不是同一个组件 直接将组件内容显示在页面中</span><br><span class="line">  // 这里为 mountElement 方法新增了一个参数 oldDOM </span><br><span class="line">  // 作用是在将 DOM 对象插入到页面前 将页面中已存在的 DOM 对象删除 否则无论是旧DOM对象还是新DOM对象都会显示在页面中</span><br><span class="line">  mountElement(virtualDOM, container, oldDOM)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 mountNativeElement 方法中删除原有的旧 DOM 对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mountNavtiveElement.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">mountNativeElement</span>(<span class="params">virtualDOM, container, oldDOM</span>) &#123;</span><br><span class="line"> <span class="comment">// 如果旧的DOM对象存在 删除</span></span><br><span class="line">  <span class="keyword">if</span> (oldDOM) &#123;</span><br><span class="line">    <span class="title function_">unmount</span>(oldDOM)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// unmount.js</span><br><span class="line">export default function unmount(node) &#123;</span><br><span class="line">  node.remove()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果是同一个组件的话，需要执行组件更新操作，需要调用组件生命周期函数</p>
<p>先在 Component 类中添加生命周期函数，子类要使用的话直接覆盖就可以</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// Component.js</span><br><span class="line">export default class Component &#123;</span><br><span class="line">  // 生命周期函数</span><br><span class="line">  componentWillMount() &#123;&#125;</span><br><span class="line">  componentDidMount() &#123;&#125;</span><br><span class="line">  componentWillReceiveProps(nextProps) &#123;&#125;</span><br><span class="line">  shouldComponentUpdate(nextProps, nextState) &#123;</span><br><span class="line">    return nextProps != this.props || nextState != this.state</span><br><span class="line">  &#125;</span><br><span class="line">  componentWillUpdate(nextProps, nextState) &#123;&#125;</span><br><span class="line">  componentDidUpdate(prevProps, preState) &#123;&#125;</span><br><span class="line">  componentWillUnmount() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新建 updateComponent 方法用于更新组件操作，并在 if 成立后调用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// diffComponent.js</span><br><span class="line">if (isSameComponent(virtualDOM, oldComponent)) &#123;</span><br><span class="line">  // 属同一个组件 做组件更新</span><br><span class="line">  updateComponent(virtualDOM, oldComponent, oldDOM, container)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 updateComponent 方法中调用组件的生命周期函数，更新组件获取最新 Virtual DOM，最终调用 diff 方法进行更新</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">import diff from &quot;./diff&quot;</span><br><span class="line"></span><br><span class="line">export default function updateComponent(</span><br><span class="line">  virtualDOM,</span><br><span class="line">  oldComponent,</span><br><span class="line">  oldDOM,</span><br><span class="line">  container</span><br><span class="line">) &#123;</span><br><span class="line">  // 生命周期函数</span><br><span class="line">  oldComponent.componentWillReceiveProps(virtualDOM.props)</span><br><span class="line">  if (</span><br><span class="line">    // 调用 shouldComponentUpdate 生命周期函数判断是否要执行更新操作</span><br><span class="line">    oldComponent.shouldComponentUpdate(virtualDOM.props)</span><br><span class="line">  ) &#123;</span><br><span class="line">    // 将未更新的 props 保存一份</span><br><span class="line">    let prevProps = oldComponent.props</span><br><span class="line">    // 生命周期函数</span><br><span class="line">    oldComponent.componentWillUpdate(virtualDOM.props)</span><br><span class="line">    // 更新组件的 props 属性 updateProps 方法定义在 Component 类型</span><br><span class="line">    oldComponent.updateProps(virtualDOM.props)</span><br><span class="line">    // 因为组件的 props 已经更新 所以调用 render 方法获取最新的 Virtual DOM</span><br><span class="line">    const nextVirtualDOM = oldComponent.render()</span><br><span class="line">    // 将组件实例对象挂载到 Virtual DOM 身上</span><br><span class="line">    nextVirtualDOM.component = oldComponent</span><br><span class="line">    // 调用diff方法更新视图</span><br><span class="line">    diff(nextVirtualDOM, container, oldDOM)</span><br><span class="line">    // 生命周期函数</span><br><span class="line">    oldComponent.componentDidUpdate(prevProps)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// Component.js</span><br><span class="line">export default class Component &#123;</span><br><span class="line">  updateProps(props) &#123;</span><br><span class="line">    this.props = props</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="10-ref-属性"><a href="#10-ref-属性" class="headerlink" title="10. ref 属性"></a>10. ref 属性</h2><p>为节点添加 ref 属性可以获取到这个节点的 DOM 对象，比如在 DemoRef 类中，为 input 元素添加了 ref 属性，目的是获取 input DOM 元素对象，在点击按钮时获取用户在文本框中输入的内容</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class DemoRef extends TinyReact.Component &#123;</span><br><span class="line">  handle() &#123;</span><br><span class="line">    let value = this.input.value</span><br><span class="line">    console.log(value)</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;input type=&quot;text&quot; ref=&#123;input =&gt; (this.input = input)&#125; /&gt;</span><br><span class="line">        &lt;button onClick=&#123;this.handle.bind(this)&#125;&gt;按钮&lt;/button&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现思路是在创建节点时判断其 Virtual DOM 对象中是否有 ref 属性，如果有就调用 ref 属性中所存储的方法并且将创建出来的DOM对象作为参数传递给 ref 方法，这样在渲染组件节点的时候就可以拿到元素对象并将元素对象存储为组件属性了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// createDOMElement.js</span><br><span class="line">if (virtualDOM.props &amp;&amp; virtualDOM.props.ref) &#123;</span><br><span class="line">  virtualDOM.props.ref(newElement)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在类组件的身上也可以添加 ref 属性，目的是获取组件的实例对象，比如下列代码中，在 DemoRef 组件中渲染了 Alert 组件，在 Alert 组件中添加了 ref 属性，目的是在 DemoRef 组件中获取 Alert 组件实例对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class DemoRef extends TinyReact.Component &#123;</span><br><span class="line">  handle() &#123;</span><br><span class="line">    let value = this.input.value</span><br><span class="line">    console.log(value)</span><br><span class="line">    console.log(this.alert)</span><br><span class="line">  &#125;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    console.log(&quot;componentDidMount&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;input type=&quot;text&quot; ref=&#123;input =&gt; (this.input = input)&#125; /&gt;</span><br><span class="line">        &lt;button onClick=&#123;this.handle.bind(this)&#125;&gt;按钮&lt;/button&gt;</span><br><span class="line">        &lt;Alert ref=&#123;alert =&gt; (this.alert = alert)&#125; /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现思路是在 mountComponent 方法中，如果判断了当前处理的是类组件，就通过类组件返回的 Virtual DOM 对象中获取组件实例对象，判断组件实例对象中的 props 属性中是否存在 ref 属性，如果存在就调用 ref 方法并且将组件实例对象传递给 ref 方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// mountComponent.js</span><br><span class="line">let component = null</span><br><span class="line">  if (isFunctionalComponent(virtualDOM)) &#123;&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">    // 类组件</span><br><span class="line">    nextVirtualDOM = buildStatefulComponent(virtualDOM)</span><br><span class="line">    // 获取组件实例对象</span><br><span class="line">    component = nextVirtualDOM.component</span><br><span class="line">  &#125;</span><br><span class="line">	// 如果组件实例对象存在的话</span><br><span class="line">	if (component) &#123;</span><br><span class="line">   	// 判断组件实例对象身上是否有 props 属性 props 属性中是否有 ref 属性</span><br><span class="line">    if (component.props &amp;&amp; component.props.ref) &#123;</span><br><span class="line">      // 调用 ref 方法并传递组件实例对象</span><br><span class="line">      component.props.ref(component)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>代码走到这，顺便处理一下组件挂载完成的生命周期函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 如果组件实例对象存在的话</span><br><span class="line">if (component) &#123;</span><br><span class="line">  component.componentDidMount()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="11-key-属性"><a href="#11-key-属性" class="headerlink" title="11. key 属性"></a>11. key 属性</h2><p>在 React 中，渲染列表数据时通常会在被渲染的列表元素上添加 key 属性，key 属性就是数据的唯一标识，帮助 React 识别哪些数据被修改或者删除了，从而达到 DOM 最小化操作的目的。</p>
<p>key 属性不需要全局唯一，但是在同一个父节点下的兄弟节点之间必须是唯一的。</p>
<p>也就是说，在比对同一个父节点下类型相同的子节点时需要用到 key 属性。</p>
<h3 id="11-1-节点对比"><a href="#11-1-节点对比" class="headerlink" title="11.1 节点对比"></a>11.1 节点对比</h3><p>实现思路是在两个元素进行比对时，如果类型相同，就循环旧的 DOM 对象的子元素，查看其身上是否有key 属性，如果有就将这个子元素的 DOM 对象存储在一个 JavaScript 对象中，接着循环要渲染的 Virtual DOM 对象的子元素，在循环过程中获取到这个子元素的 key 属性，然后使用这个 key 属性到 JavaScript 对象中查找 DOM 对象，如果能够找到就说明这个元素是已经存在的，是不需要重新渲染的。如果通过key属性找不到这个元素，就说明这个元素是新增的是需要渲染的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// diff.js</span><br><span class="line">else if (oldVirtualDOM &amp;&amp; virtualDOM.type === oldVirtualDOM.type) &#123;</span><br><span class="line">  // 将拥有key属性的元素放入 keyedElements 对象中</span><br><span class="line">  let keyedElements = &#123;&#125;</span><br><span class="line">  for (let i = 0, len = oldDOM.childNodes.length; i &lt; len; i++) &#123;</span><br><span class="line">    let domElement = oldDOM.childNodes[i]</span><br><span class="line">    if (domElement.nodeType === 1) &#123;</span><br><span class="line">      let key = domElement.getAttribute(&quot;key&quot;)</span><br><span class="line">      if (key) &#123;</span><br><span class="line">        keyedElements[key] = domElement</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">// diff.js</span><br><span class="line">// 看一看是否有找到了拥有 key 属性的元素</span><br><span class="line">let hasNoKey = Object.keys(keyedElements).length === 0</span><br><span class="line"></span><br><span class="line">// 如果没有找到拥有 key 属性的元素 就按照索引进行比较</span><br><span class="line">if (hasNoKey) &#123;</span><br><span class="line">  // 递归对比 Virtual DOM 的子元素</span><br><span class="line">  virtualDOM.children.forEach((child, i) =&gt; &#123;</span><br><span class="line">    diff(child, oldDOM, oldDOM.childNodes[i])</span><br><span class="line">  &#125;)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  // 使用key属性进行元素比较</span><br><span class="line">  virtualDOM.children.forEach((child, i) =&gt; &#123;</span><br><span class="line">    // 获取要进行比对的元素的 key 属性</span><br><span class="line">    let key = child.props.key</span><br><span class="line">    // 如果 key 属性存在</span><br><span class="line">    if (key) &#123;</span><br><span class="line">      // 到已存在的 DOM 元素对象中查找对应的 DOM 元素</span><br><span class="line">      let domElement = keyedElements[key]</span><br><span class="line">      // 如果找到元素就说明该元素已经存在 不需要重新渲染</span><br><span class="line">      if (domElement) &#123;</span><br><span class="line">        // 虽然 DOM 元素不需要重新渲染 但是不能确定元素的位置就一定没有发生变化</span><br><span class="line">        // 所以还要查看一下元素的位置</span><br><span class="line">        // 看一下 oldDOM 对应的(i)子元素和 domElement 是否是同一个元素 如果不是就说明元素位置发生了变化</span><br><span class="line">        if (oldDOM.childNodes[i] &amp;&amp; oldDOM.childNodes[i] !== domElement) &#123;</span><br><span class="line">          // 元素位置发生了变化</span><br><span class="line">          // 将 domElement 插入到当前元素位置的前面 oldDOM.childNodes[i] 就是当前位置</span><br><span class="line">          // domElement 就被放入了当前位置</span><br><span class="line">          oldDOM.insertBefore(domElement, oldDOM.childNodes[i])</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        mountElement(child, oldDOM, oldDOM.childNodes[i])</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// mountNativeElement.js</span><br><span class="line">if (oldDOM) &#123;</span><br><span class="line">  container.insertBefore(newElement, oldDOM)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  // 将转换之后的DOM对象放置在页面中</span><br><span class="line">  container.appendChild(newElement)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="11-2-节点卸载"><a href="#11-2-节点卸载" class="headerlink" title="11.2 节点卸载"></a>11.2 节点卸载</h3><p>在比对节点的过程中，如果旧节点的数量多于要渲染的新节点的数量就说明有节点被删除了，继续判断 keyedElements 对象中是否有元素，如果没有就使用索引方式删除，如果有就要使用 key 属性比对的方式进行删除。</p>
<p>实现思路是循环旧节点，在循环旧节点的过程中获取旧节点对应的 key 属性，然后根据 key 属性在新节点中查找这个旧节点，如果找到就说明这个节点没有被删除，如果没有找到，就说明节点被删除了，调用卸载节点的方法卸载节点即可。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// 获取就节点的数量</span><br><span class="line">let oldChildNodes = oldDOM.childNodes</span><br><span class="line">// 如果旧节点的数量多于要渲染的新节点的长度</span><br><span class="line">if (oldChildNodes.length &gt; virtualDOM.children.length) &#123;</span><br><span class="line">  if (hasNoKey) &#123;</span><br><span class="line">    for (</span><br><span class="line">      let i = oldChildNodes.length - 1;</span><br><span class="line">      i &gt;= virtualDOM.children.length;</span><br><span class="line">      i--</span><br><span class="line">    ) &#123;</span><br><span class="line">      oldDOM.removeChild(oldChildNodes[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    for (let i = 0; i &lt; oldChildNodes.length; i++) &#123;</span><br><span class="line">      let oldChild = oldChildNodes[i]</span><br><span class="line">      let oldChildKey = oldChild._virtualDOM.props.key</span><br><span class="line">      let found = false</span><br><span class="line">      for (let n = 0; n &lt; virtualDOM.children.length; n++) &#123;</span><br><span class="line">        if (oldChildKey === virtualDOM.children[n].props.key) &#123;</span><br><span class="line">          found = true</span><br><span class="line">          break</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      if (!found) &#123;</span><br><span class="line">        unmount(oldChild)</span><br><span class="line">        i--</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>卸载节点并不是说将节点直接删除就可以了，还需要考虑以下几种情况</p>
<ol>
<li>如果要删除的节点是文本节点的话可以直接删除</li>
<li>如果要删除的节点由组件生成，需要调用组件卸载生命周期函数</li>
<li>如果要删除的节点中包含了其他组件生成的节点，需要调用其他组件的卸载生命周期函数</li>
<li>如果要删除的节点身上有 ref 属性，还需要删除通过 ref 属性传递给组件的 DOM 节点对象</li>
<li>如果要删除的节点身上有事件，需要删除事件对应的事件处理函数</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">export default function unmount(dom) &#123;</span><br><span class="line">  // 获取节点对应的 virtualDOM 对象</span><br><span class="line">  const virtualDOM = dom._virtualDOM</span><br><span class="line">  // 如果要删除的节点时文本</span><br><span class="line">  if (virtualDOM.type === &quot;text&quot;) &#123;</span><br><span class="line">    // 直接删除节点</span><br><span class="line">    dom.remove()</span><br><span class="line">    // 阻止程序向下运行</span><br><span class="line">    return</span><br><span class="line">  &#125;</span><br><span class="line">  // 查看节点是否由组件生成</span><br><span class="line">  let component = virtualDOM.component</span><br><span class="line">  // 如果由组件生成</span><br><span class="line">  if (component) &#123;</span><br><span class="line">    // 调用组件卸载生命周期函数</span><br><span class="line">    component.componentWillUnmount()</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  // 如果节点具有 ref 属性 通过再次调用 ref 方法 将传递给组件的DOM对象删除</span><br><span class="line">  if (virtualDOM.props &amp;&amp; virtualDOM.props.ref) &#123;</span><br><span class="line">    virtualDOM.props.ref(null)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 事件处理</span><br><span class="line">  Object.keys(virtualDOM.props).forEach(propName =&gt; &#123;</span><br><span class="line">    if (propName.slice(0, 2) === &quot;on&quot;) &#123;</span><br><span class="line">      const eventName = propName.toLowerCase().slice(2)</span><br><span class="line">      const eventHandler = virtualDOM.props[propName]</span><br><span class="line">      dom.removeEventListener(eventName, eventHandler)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">	</span><br><span class="line">  // 递归删除子节点</span><br><span class="line">  if (dom.childNodes.length &gt; 0) &#123;</span><br><span class="line">    for (let i = 0; i &lt; dom.childNodes.length; i++) &#123;</span><br><span class="line">      unmount(dom.childNodes[i])</span><br><span class="line">      i--</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  	</span><br><span class="line">  dom.remove()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>









      </section>

      
      

      
      
    </div>
    <div class="widget-info">
      <section class="widget-author widget-item layout-margin content-padding--primary soft-size--large soft-style--box">
  <div class="widget-body">
    
      <img src="https://img1.baidu.com/it/u=1088540074,3334562162&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=237&amp;h=221" class="soft-size--round soft-style--box" alt="GYB">
    
    
      <h2>GYB</h2>
    
    
      <p>日拱一卒，功不唐捐</p>
    

    <div class="count-box">
      <div class="count-box--item">
        <svg class="icon icon-article" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">
  <path d="M240.51564747 647.74217627h196.07203239c16.59071043 0 30.16492806-13.57421762 30.16492805-30.16492806V165.10332731c0-33.18142087-30.16492806-60.32985613-60.32985612-60.32985611H245.04038668C225.43318342 104.7734712 210.35071939 119.85593522 210.35071939 139.46313845V617.57724821c0 16.59071043 13.57421762 30.16492806 30.16492808 30.16492806z m663.62841731-452.47392089v482.63884894c0 33.18142087-27.14843525 60.32985613-60.32985612 60.32985613H180.18579134c-33.18142087 0-60.32985613-27.14843525-60.32985612-60.32985613V195.26825538c-49.77213131 0-90.49478418 40.72265287-90.49478417 90.49478417v452.4739209c0 49.77213131 40.72265287 90.49478418 90.49478417 90.49478417h286.56681657c16.59071043 0 30.16492806 13.57421762 30.16492807 30.16492807s13.57421762 30.16492806 30.16492805 30.16492806h90.49478418c16.59071043 0 30.16492806-13.57421762 30.16492805-30.16492806s13.57421762-30.16492806 30.16492807-30.16492807h286.56681657c49.77213131 0 90.49478418-40.72265287 90.49478417-90.49478417V285.76303955c0-49.77213131-40.72265287-90.49478418-90.49478417-90.49478417zM587.41232014 647.74217627h191.54729318c19.60720323 0 34.68966726-15.08246403 34.68966729-34.68966727V134.93839925c0-16.59071043-13.57421762-30.16492806-30.16492808-30.16492805H617.57724821c-30.16492806 0-60.32985613 27.14843525-60.32985612 60.32985611v452.4739209c0 16.59071043 13.57421762 30.16492806 30.16492805 30.16492806z" fill="currentColor"></path>
</svg>
        <span>5</span>
      </div>
      <div class="count-box--item">
        <svg class="icon icon-categories" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">
  <path d="M900.3614811 257.09082106h-339.81629553l-67.96326003-101.9448889c-19.41807444-29.12711113-48.54518557-43.69066667-82.52681443-43.69066667H123.6385189c-53.39970333 0-97.09036999 43.69066667-97.09037113 97.09036999v582.54222222c0 53.39970333 43.69066667 97.09036999 97.09037113 97.09037002h776.7229622c53.39970333 0 97.09036999-43.69066667 97.09037113-97.09037002V354.18119104c0-53.39970333-43.69066667-97.09036999-97.09037113-97.09036998z m-97.09036999 242.72592554H220.72888889c-24.27259221 0-48.54518557-24.27259221-48.54518556-48.54518556s24.27259221-48.54518557 48.54518556-48.54518444h582.54222222c24.27259221 0 48.54518557 24.27259221 48.54518556 48.54518444s-24.27259221 48.54518557-48.54518556 48.54518556z" fill="currentColor"></path>
</svg>
        2
      </div>
      <div class="count-box--item">
        <svg class="icon icon-tags" viewBox="0 0 1098 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">
  <path d="M283.42180005 272q0-28.38857157-20.09142843-48.48000001t-48.47999998-20.09142842-48.48000002 20.09142842-20.09142846 48.48000001 20.09142846 48.48 48.48000002 20.09142843 48.47999998-20.09142843 20.09142843-48.48zM855.0332285 580.57142843q0 28.38857157-19.81714313 48.2057147l-263.03999997 263.58857157q-20.9142853 19.81714313-48.75428534 19.81714312-28.38857157 0-48.20571468-19.81714312l-383.04-383.58857157q-20.36571468-19.81714313-34.55999999-54.10285688t-14.19428534-62.6742853l0-222.85714313q0-27.84000002 20.36571469-48.20571469t48.2057147-20.36571466l222.85714313 0q28.38857157 0 62.6742853 14.19428529t54.65142842 34.55999999l383.04000001 382.49142843q19.81714313 20.9142853 19.81714314 48.75428532zM1060.74751475 580.57142843q0 28.38857157-19.81714313 48.2057147l-263.04 263.58857157q-20.9142853 19.81714313-48.75428531 19.81714312-19.26857155 0-31.61142843-7.47428531t-28.38857159-24.13714314l251.79428534-251.7942853q19.81714313-19.81714313 19.81714308-48.20571469 0-27.84000002-19.81714308-48.75428531l-383.04000001-382.49142845q-20.36571468-20.36571468-54.65142842-34.55999999t-62.67428532-14.19428534l120 0q28.38857157 0 62.67428532 14.19428534t54.65142842 34.55999999l383.03999998 382.49142845q19.81714313 20.9142853 19.81714314 48.75428531z" fill="currentColor"></path>
</svg>
        2
      </div>
    </div>
  </div>
</section>

      
<section class="widet-notice widget-item layout-margin content-padding--primary soft-size--large soft-style--box">
  <div class="widget-title">
    <svg class="icon icon-notice" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">
  <path d="M512 945.02305225v28.15620663a24.27259221 24.27259221 0 0 1-24.27259221 24.27259335H394.0352a48.54518557 48.54518557 0 0 1-41.74885888-23.78714112l-110.68302222-184.47170332a132.04290333 132.04290333 0 0 1-17.47626667-48.54518557h118.4502511a200.97706667 200.97706667 0 0 1 76.21594113 14.56355556l20.38897777 133.49925888a48.54518557 48.54518557 0 0 0 36.40888888 27.67075555l16.01991111 2.91271112a24.27259221 24.27259221 0 0 1 20.38897778 25.72894889zM997.45185223 463.45481443a194.18074112 194.18074112 0 0 1-38.8361489 116.50844445 24.75804445 24.75804445 0 0 1-36.4088889 0l-34.95253333-34.95253333a24.27259221 24.27259221 0 0 1-2.91271111-30.58346667 97.09036999 97.09036999 0 0 0 0-106.79940665 24.27259221 24.27259221 0 0 1 2.91271111-30.58346666l34.95253333-34.95253334a24.75804445 24.75804445 0 0 1 18.93262223-7.28177777 26.2144 26.2144 0 0 1 17.47626667 9.70903665A194.18074112 194.18074112 0 0 1 997.45185223 463.45481443z m-194.18074112-388.36148111v776.72296335a48.54518557 48.54518557 0 0 1-48.54518556 48.54518443h-28.64165888a48.54518557 48.54518557 0 0 1-33.98163001-14.07810332l-145.63555556-143.20829668A291.27111111 291.27111111 0 0 0 342.57730333 657.63555556H172.18370333a145.63555556 145.63555556 0 0 1-145.63555556-145.63555556v-97.09036999a145.63555556 145.63555556 0 0 1 145.63555556-145.63555556h170.3936a291.27111111 291.27111111 0 0 0 206.31703779-85.43952668l145.63555555-143.20829554a48.54518557 48.54518557 0 0 1 33.98162888-14.07810446H754.72592555a48.54518557 48.54518557 0 0 1 48.54518556 48.54518555z" fill="currentColor"></path>
</svg>
    <span>NOTICE</span>
  </div>
  <div class="widget-body">
    <p>持续更新中。。。</p>
  </div>
</section>


      <section class="widget-categorys widget-item layout-margin content-padding--primary soft-size--large soft-style--box">
  <div class="widget-title">
    <svg class="icon icon-categories" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">
  <path d="M900.3614811 257.09082106h-339.81629553l-67.96326003-101.9448889c-19.41807444-29.12711113-48.54518557-43.69066667-82.52681443-43.69066667H123.6385189c-53.39970333 0-97.09036999 43.69066667-97.09037113 97.09036999v582.54222222c0 53.39970333 43.69066667 97.09036999 97.09037113 97.09037002h776.7229622c53.39970333 0 97.09036999-43.69066667 97.09037113-97.09037002V354.18119104c0-53.39970333-43.69066667-97.09036999-97.09037113-97.09036998z m-97.09036999 242.72592554H220.72888889c-24.27259221 0-48.54518557-24.27259221-48.54518556-48.54518556s24.27259221-48.54518557 48.54518556-48.54518444h582.54222222c24.27259221 0 48.54518557 24.27259221 48.54518556 48.54518444s-24.27259221 48.54518557-48.54518556 48.54518556z" fill="currentColor"></path>
</svg>
    <span>CATEGORYS</span>
  </div>
  <div class="widget-body">
    <ul class="categorys-list">
      
        <li class="categorys-list-item">
          <a href="/GYB_blog/categories/web%E5%89%8D%E7%AB%AF/">
            web前端 (5)
          </a>
        </li>
      
        <li class="categorys-list-item">
          <a href="/GYB_blog/categories/web%E5%89%8D%E7%AB%AF/react/">
            react (5)
          </a>
        </li>
      
    </ul>
  </div>
</section>

      <section class="widget-tags widget-item  layout-margin content-padding--primary soft-size--large soft-style--box">
  <div class="widget-title">
    <svg class="icon icon-tags" viewBox="0 0 1098 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">
  <path d="M283.42180005 272q0-28.38857157-20.09142843-48.48000001t-48.47999998-20.09142842-48.48000002 20.09142842-20.09142846 48.48000001 20.09142846 48.48 48.48000002 20.09142843 48.47999998-20.09142843 20.09142843-48.48zM855.0332285 580.57142843q0 28.38857157-19.81714313 48.2057147l-263.03999997 263.58857157q-20.9142853 19.81714313-48.75428534 19.81714312-28.38857157 0-48.20571468-19.81714312l-383.04-383.58857157q-20.36571468-19.81714313-34.55999999-54.10285688t-14.19428534-62.6742853l0-222.85714313q0-27.84000002 20.36571469-48.20571469t48.2057147-20.36571466l222.85714313 0q28.38857157 0 62.6742853 14.19428529t54.65142842 34.55999999l383.04000001 382.49142843q19.81714313 20.9142853 19.81714314 48.75428532zM1060.74751475 580.57142843q0 28.38857157-19.81714313 48.2057147l-263.04 263.58857157q-20.9142853 19.81714313-48.75428531 19.81714312-19.26857155 0-31.61142843-7.47428531t-28.38857159-24.13714314l251.79428534-251.7942853q19.81714313-19.81714313 19.81714308-48.20571469 0-27.84000002-19.81714308-48.75428531l-383.04000001-382.49142845q-20.36571468-20.36571468-54.65142842-34.55999999t-62.67428532-14.19428534l120 0q28.38857157 0 62.67428532 14.19428534t54.65142842 34.55999999l383.03999998 382.49142845q19.81714313 20.9142853 19.81714314 48.75428531z" fill="currentColor"></path>
</svg>
    <span>TAGS</span>
  </div>
  <div class="widget-body">
    <div class="tags-cloud">
      <a href="/GYB_blog/tags/react/" style="font-size: 10px;" class="tags-cloud-0">react</a> <a href="/GYB_blog/tags/web%E5%89%8D%E7%AB%AF/" style="font-size: 10px;" class="tags-cloud-0">web前端</a>
    </div>
  </div>
</section>
    </div>
  </article>
</div>


    <!-- footer container -->
<footer id="footer" class="footer">
  <div class="footer-container">
    
    <div class="social-icons">
      
        
      
        
      
        
      
        
          <a href="https://github.com/gaoyubo01" class="soft-size--primary soft-style--box" target="_blank" rel="noopener noreferrer">
            <svg class="icon icon-github" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">
  <path d="M64.6 512c0 195.6 125.4 361.9 300.1 422.9 23.5 5.9 19.9-10.8 19.9-22.2v-77.6c-135.8 15.9-141.3-74-150.5-89-18.5-31.5-61.9-39.5-49-54.5 31-15.9 62.5 4 98.9 58 26.4 39.1 77.9 32.5 104.1 26 5.7-23.5 17.9-44.5 34.7-60.9-140.7-25.2-199.4-111.1-199.4-213.3 0-49.5 16.4-95.1 48.4-131.8-20.4-60.6 1.9-112.4 4.9-120.1 58.2-5.2 118.5 41.6 123.3 45.3 33.1-8.9 70.8-13.7 112.9-13.7 42.4 0 80.3 4.9 113.5 13.9 11.3-8.6 67.3-48.8 121.4-43.9 2.9 7.7 24.7 58.3 5.5 118.1 32.5 36.8 49 82.8 49 132.4 0 102.3-59 188.3-200.2 213.2 23.5 23.3 38.1 55.5 38.1 91.1v112.7c0.8 9 0 17.9 15.1 17.9C832.7 877 960.4 709.4 960.4 512.1c0-247.5-200.6-447.9-447.9-447.9C265 64.1 64.6 264.5 64.6 512z"></path>
</svg>
          </a>
        
      
        
      
    </div>
     
    <p>&copy; 2022 <a href="/" target="_blank">John Doe</a></p>

    

    <!-- <p>Powered by <a href="https://hexo.io" target="_blank" rel="noopener noreferrer">Hexo</a> Theme - <a href="https://github.com/miiiku/flex-block" target="_blank" rel="noopener noreferrer author">flex-block</a></p> -->

    <p>
      <a href="javascript:;" id="theme-light">🌞 浅色</a>
      <a href="javascript:;" id="theme-dark">🌛 深色</a>
      <a href="javascript:;" id="theme-auto">🤖️ 自动</a>
    </p>
    <span id="busuanzi_container_site_uv"><br>
      本站访客数<span id="busuanzi_value_site_uv"></span>人次
    </span>
  </div>
</footer>
  </div>

  <div class="back-to-top-fixed soft-size--round soft-style--box">
    <svg class="icon icon-back-to-top" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">
      <path d="M725.333333 426.666667c-12.8 0-21.333333-4.266667-29.866667-12.8l-213.333333-213.333333c-17.066667-17.066667-17.066667-42.666667 0-59.733333s42.666667-17.066667 59.733333 0l213.333333 213.333333c17.066667 17.066667 17.066667 42.666667 0 59.733333C746.666667 422.4 738.133333 426.666667 725.333333 426.666667z"></path>
      <path d="M298.666667 426.666667c-12.8 0-21.333333-4.266667-29.866667-12.8-17.066667-17.066667-17.066667-42.666667 0-59.733333l213.333333-213.333333c17.066667-17.066667 42.666667-17.066667 59.733333 0s17.066667 42.666667 0 59.733333l-213.333333 213.333333C320 422.4 311.466667 426.666667 298.666667 426.666667z"></path>
      <path d="M512 896c-25.6 0-42.666667-17.066667-42.666667-42.666667L469.333333 170.666667c0-25.6 17.066667-42.666667 42.666667-42.666667s42.666667 17.066667 42.666667 42.666667l0 682.666667C554.666667 878.933333 537.6 896 512 896z"></path>
    </svg>
  </div>

  
  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<!-- aplayer -->


<!-- dplayer -->




  


  


  




<script src="/GYB_blog/js/script.js"></script>


  
  <!-- 尾部用户自定义相关内容 -->
</body>
</html>
